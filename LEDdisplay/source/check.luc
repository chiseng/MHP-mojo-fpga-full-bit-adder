module check (

    
// module checks if a coconut has been caught by the user
    
    
    input clk,  // clock
    input rst,  // reset
    input cols[16][14],    // column values of current cycle
    input rows[2][16],      // row values of current cycle
    input score[8],           // current score    
    output outscore[8]        // output score
  ) {
  // instantiate the alu module
  //alu alu;
  
  
  // ALUFN value for the different functions used
  const AND = 6b011000;
  const ADD = 6b000000;
  
  .clk(clk){.rst(rst){dff score_save[8]; dff tempcheck[16]; dff z;}}
  // temp values
  sig msb[16];         // most significant bits of the columns (the row closest to the user collector) 
//  sig tempcheck[16];   // temp value to store the output after AND-ing msb with user location (msb AND rows[1])) 
//  sig z;               // store z value
  
  
  var i;        // for loop to get msb

  always {
    score_save.d=score;
    //get the most significant bits from each column
    for ( i=0; i<16; i++){
      msb[15-i] = cols[i][13];
    }
    
    // [15] =[0][13]
    // [0] = [15][13]
    
    
    // AND msb with rows[1] to check if coocnut coincides with user location
    /*
    alu.a = msb;
    alu.b = rows[1];
    alu.alufn = AND;
    tempcheck = alu.out;
    */
    
    tempcheck.d = msb & rows[1];
    
    
    // add up all values from AND output; ie. checking if any coconut is caught
    // if yes, z > 0; else z = 0
    z.d = tempcheck.q[0] + tempcheck.q[1] + tempcheck.q[2] + tempcheck.q[3] + tempcheck.q[4] + tempcheck.q[5] + tempcheck.q[6] + tempcheck.q[7] + tempcheck.q[8] + tempcheck.q[9] + tempcheck.q[10] + tempcheck.q[11] + tempcheck.q[12] + tempcheck.q[13] + tempcheck.q[14] + tempcheck.q[15];
    
    
    if (z.q > 0){
    // coconut is caught; add 1 to score
      
      score_save.d=score_save.q + 8b1;
      outscore = score_save.q;
    }
    
    else{
    // coconut is not caught; score remains unchanged

      score_save.d=score_save.q;
      outscore = score_save.q;
    }
    
  }
}