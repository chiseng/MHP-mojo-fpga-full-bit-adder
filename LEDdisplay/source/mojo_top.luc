module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    
    
    input button_onoff,            // button to on/off
    input button_l,         // left button
    input button_r,         // right button
    
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    //output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    //output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    //input io_dip [3][8]     // DIP switches on IO Shield
    output a[16],
    output c[16],
    input button2

  ) {
  
  sig rst;                  // reset signal
  const GEN_BOTROWS={16b0000011100000000,16b0000011100000000};          // temp storage of the rows from generator_bottom
  sig gen_topcols[16][14];          // temp storage of the cols from generator_top
  var i;    
  fsm gamefsm(.clk(clk), .rst(rst), #INIT(INIT_STAGE)) = {IDLE, INIT_STAGE, CHECK_MOVE, CHECK_SCORE};
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
//    button_conditioner button_start;
//      edge_detector edge_start;
    .rst(rst){
      //multi_seven_seg seg;
      generator_bottom generator_bottom;
      generator_top generator_top;
      check check;
      //leddisplay leddisplay;
      
      dff normclock[30];
      registerScore regscore;
      registerScore registerCols;
     
     
     counter slowclock(#SIZE(1),#DIV(8));  //smaller the faster the refresh 
     led_matrix ld;
     leddisplay led_converter;
    }
  }

    .clk(slowclock.value) {
     fsm state (#INIT(ONE)) = {ONE,TWO, THREE};
     dff cSignal[16](.rst(rst));
     dff aSignal[16](.rst(rst));
    }
  sig start;
  always {
//  button_start.in=button_s;
//    edge_detector.in=button_s.out;
//    start=edge_detector.out;
  regscore.en=0;
  regscore.data=0;
  registerCols.en=0;
  registerCols.data=0;
  io_seg = 8hff;          // turn segments off    
  a = 16b0;
  c = 16b0;

  reset_cond.in = ~rst_n; // input raw inverted reset signal
  rst = reset_cond.out;   // conditioned reset

  
  led = 8h00;             // turn LEDs off
  spi_miso = bz;          // not using SPI
  spi_channel = bzzzz;    // not using flags
  avr_rx = bz;            // not using serial port
  
    // initialise things
    generator_bottom.button_l = button_l;
    generator_bottom.button_r = button_r;
    gen_botrows[0] = 16b0000011100000000;
    gen_botrows[1] = 16b0000011100000000;
    generator_bottom.rows = gen_botrows;
    led_converter.rows = ~generator_bottom.rowsout;

    
    for ( i=0; i<16; i++){
          gen_topcols[i] = 14b0;
          }
    generator_top.cols = gen_topcols;
    
    led_converter.cols = ~generator_top.colsout;
    
    ld.pattern = led_converter.out;
    // ****** CHANGED ******    
    
    check.cols = generator_top.colsout;
    check.rows = generator_bottom.rowsout;
    check.score = score.q;
//    led=generator_bottom.rowsout[1][15:8];\
    led=generator_bottom.led; //connect bottom to leds
    //led=check.outscore;
    generator_bottom.button_l = button_l;
    generator_bottom.button_r = button_r;
    score.d = check.outscore;
    a=ld.a;
    c=ld.c;
   
    
    
    case (gamefsm.q)  {
    /*
      gamefsm.IDLE:
        if (start==1){
        gamefsm.d=gamefsm.INIT_STAGE;
        }
      */    
        
      gamefsm.INIT_STAGE:
        // initialise the playground; user in the middle
        // no coconuts
        gen_botrows[0] = ~16b0000001110000000;
        gen_botrows[1] = ~16b0000001110000000;
        generator_bottom.rows=gen_botrows;
        led_converter.rows=generator_bottom.rowsout;
        
        //cols[16][14]
        for ( i=0; i<16; i++){
          gen_topcols[i] = ~14b0;
          }

        
//        led_converter.cols=gen_topcols;
        // save the generator_bottom.rowsout
        // display it
        
//        currentrows.d = generator_bottom.rowsout;
//        if(gamefsm.q!=gamefsm.STAGE1) currentrows.d=currentrows.q;
        led_converter.rows = generator_bottom.rowsout;
        led=generator_bottom.led;
        registerCols.en=1;
        registerCols.data=gen_topcols;
        
        
        //save the generator_top.colsout;
        // display it
        currentcols.d = generator_top.colsout;
//        if(gamefsm.q!=gamefsm.STAGE1) currentcols.d=currentcols.q;
        led_converter.cols = generator_top.colsout;
        
        ld.pattern = led_converter.out;
        a = ld.a;
        c = ld.c;
        gamefsm.d = gamefsm.CHECK_MOVE;
        
             
      gamefsm.CHECK_MOVE:
      
      /*
        // pass in the prev saved rowsout & colsout
        generator_bottom.rows = currentrows.q;
        
        generator_bottom.button_l = button_l;
        generator_bottom.button_r = button_r;
        
        generator_top.cols = currentcols.q;
        
        // if timer != 0
        //check if score + 1
        check.cols = generator_top.colsout;
        check.rows = generator_bottom.rowsout;
        check.score = score.q;
        score.d = check.outscore;
        
        gamefsm.d = gamefsm.STAGE1;
        
        //else if timer == 0
        //state.d= = state.IDLE;
    
        */
  
}
}

