module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    
    
    input button_onoff,            // button to on/off
    input button_l,         // left button
    input button_r,         // right button
    
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    //output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    //output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    //input io_dip [3][8]     // DIP switches on IO Shield
    output a[16],
    output c[16],
    input button2

  ) {
  
  sig rst;                  // reset signal
  const GEN_BOTROWS={16b0000011100000000,16b0000011100000000};          // temp storage of the rows from generator_bottom
  sig gen_topcols[16][14];          // temp storage of the cols from generator_top
  var i;        // used for the for loop to initialise columns
  fsm gamefsm(.clk(clk), .rst(rst), #INIT(INIT_STAGE)) = {IDLE, INIT_STAGE, CHECK_MOVE, CHECK_SCORE};
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
//    button_conditioner button_start;
//      edge_detector edge_start;
    .rst(rst){
      //multi_seven_seg seg;
      generator_bottom generator_bottom;
//      generator_top generator_top;      
      check check;
      //leddisplay leddisplay;
      
      dff normclock[30];
      registerScore regscore; //takes in the score
      registerCols registerCols; //takes in the current cols
      registerChecker check_for_cols;
     
     counter slowclock(#SIZE(1),#DIV(8));  //smaller the faster the refresh 
     led_matrix ld;
     leddisplay led_converter;
     levels nextLevel;
    }
  }

    .clk(slowclock.value) {
     fsm state (#INIT(ONE)) = {ONE,TWO, THREE};
     dff cSignal[16](.rst(rst));
     dff aSignal[16](.rst(rst));
    }
  sig start;
  always {
//  button_start.in=button_s;
//    edge_detector.in=button_s.out;
//    start=edge_detector.out;
  regscore.en=0;
  regscore.data=0;
  registerCols.en=0;
  check_for_cols.en=0;
  check_for_cols.data=0;
  nextLevel.level=0;      
  registerCols.data=nextLevel.colsout;
  io_seg = 8hff;          // turn segments off    
  a = 16b0;
  c = 16b0;

  reset_cond.in = ~rst_n; // input raw inverted reset signal
  rst = reset_cond.out;   // conditioned reset

  
  led = 8h00;             // turn LEDs off
  spi_miso = bz;          // not using SPI
  spi_channel = bzzzz;    // not using flags
  avr_rx = bz;            // not using serial port
  
    // initialise things
    generator_bottom.button_l = button_l;
    generator_bottom.button_r = button_r;
    generator_bottom.rows = GEN_BOTROWS;
    led_converter.rows = ~generator_bottom.rowsout;

    /*
    for ( i=0; i<16; i++){
          gen_topcols[i] = 14b0;
          }
    registerCols.data=gen_topcols;            
    */
    
    led_converter.cols = ~nextLevel.colsout;
    
    ld.pattern = led_converter.out;
    // ****** CHANGED ******    
    
    check.cols = nextLevel.colsout;
    check.rows = generator_bottom.rowsout;
    regscore.en=0;
    regscore.data=0;
    
//    led=generator_bottom.rowsout[1][15:8];
    generator_bottom.button_l = button_l;
    generator_bottom.button_r = button_r;
    normclock.d=normclock.q+1;
//    score.d = check.outscore;
    a=ld.a;
    c=ld.c;
   
    
    
    case (gamefsm.q)  {
    /*
      gamefsm.IDLE:
        if (start==1){
        gamefsm.d=gamefsm.INIT_STAGE;
        }
      */    
        
      gamefsm.INIT_STAGE:
        // initialise the playground; user in the middle
        // no coconuts
        /*
        gen_botrows[0] = ~16b0000001110000000;
        gen_botrows[1] = ~16b0000001110000000;
        generator_bottom.rows=gen_botrows;        
           */
        generator_bottom.rows=GEN_BOTROWS;
        led_converter.rows=generator_bottom.rowsout;
        
        //cols[16][14]
        /*
        for ( i=0; i<16; i++){
          gen_topcols[i] = ~14b0;
          }        

        */
//        led_converter.cols=gen_topcols;
        // save the generator_bottom.rowsout
        // display it
        
//        currentrows.d = generator_bottom.rowsout;
//        if(gamefsm.q!=gamefsm.STAGE1) currentrows.d=currentrows.q;
        led_converter.rows = generator_bottom.rowsout;
        registerCols.en=1;
        registerCols.data=nextLevel.colsout;
//        if(gamefsm.q!=gamefsm.STAGE1) currentcols.d=currentcols.q;
        led_converter.cols = registerCols.out;
        
        ld.pattern = led_converter.out;
        a = ld.a;
        c = ld.c;
        gamefsm.d = gamefsm.CHECK_MOVE;
        
      gamefsm.CHECK_MOVE:
        check_for_cols.en=0;
        registerCols.en=0;
        regscore.en=0;
        if(normclock.q[24]==1){
           registerCols.en=1;
           check_for_cols.en=1;
           check_for_cols.data=check_for_cols.out+1;
           nextLevel.level=check_for_cols.out;
           registerCols.data=nextLevel.colsout;
           normclock.d=0;
        }
        led_converter.cols=nextLevel.colsout;
        led = nextLevel.colsout[13][7:0];
        generator_bottom.button_l = button_l;
        generator_bottom.button_r = button_r;

        gamefsm.d = gamefsm.CHECK_SCORE;
        
        //else if timer == 0
        //state.d= = state.IDLE;
    
        
      gamefsm.CHECK_SCORE:
      if(normclock.q[24]==1){
        check_for_cols.en=1;
        registerCols.en=1;
        
        check_for_cols.data=check_for_cols.out+1;
        nextLevel.level=check_for_cols.out;
        registerCols.data=nextLevel.colsout;
          
        normclock.d=0;
        }
      check.rows=generator_bottom.rowsout;
      check.cols=registerCols.out;
      if(check.changescore==1){
        regscore.en=1;
        regscore.data=regscore.out+1;
        led=regscore.out;
        }
      gamefsm.d=gamefsm.CHECK_MOVE;
      
  }
}
}

