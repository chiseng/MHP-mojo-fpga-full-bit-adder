module generator_bottom (

// module generates the 2 rows of the LED matrix    
    
    input clk,  // clock
    input rst,  // reset
    input button_l[1],        // left button from user input
    input button_r[1],        // right button from user input
    input rows[2][16],        // rows values from previous cycle
    output rowsout[2][16],     // rows values for current cycle
    output led[8]
  ) {
  // instantiate the alu module
  alu alu;
  
  // ALUFN value for the different functions used
  const XOR = 6b010110;
  const SHL = 6b100000;
  const SHR = 6b100001;
  
  .clk(clk){
  // temp values of outputs of ALU
  dff xoroutput[16];       // to check if both buttons are pressed simultaneously
  dff shiftleft[2][16];    // to save rowsout values if left is pressed
  dff shiftright[2][16];   // to save rowsout values if right is pressed
  dff shiftstore[16];
    counter c(#SIZE(32), #DIV(24));
  .rst(rst){
    fsm new_fsm={IDLE, LEFT, RIGHT, SAVED_STATE};
    
    } 
  }
  
  always {
    // initialise rowsout values 
    rowsout[0] = 16b0;
    rowsout[1] = 16b0;
    led=8h00;
    /*
    alu.a = button_l;      // button_l XOR button_r
    alu.b = button_r;
    alu.alufn = XOR;
    xoroutput.d = alu.out;
    
    alu.a = rows[0];      // shift left row 0 by 1 
    alu.b = 1;
    alu.alufn = SHL;
    shiftleft.d[0] = alu.out;
    
    alu.a = rows[1];      // shift left row 1 by 1
    alu.b = 1;
    alu.alufn = SHL;
    shiftleft.d[1] = alu.out;
    
    alu.a = rows[0];      // shift right row 0 by 1
    alu.b = 1;
    alu.alufn = SHR;
    shiftright.d[0] = alu.out;
    
    alu.a = rows[1];      // shift right row 1 by 1
    alu.b = 1;
    alu.alufn = SHR;
    shiftright.d[1] = alu.out;
    */
    alu.a = 0;      // button_l XOR button_r
    alu.b = 0;
    alu.alufn = 0;
    
    c.rst = rst;
    led = rows[0][15:8];
    rowsout= {shiftstore.q,shiftstore.q};
    
    case(new_fsm.q){
      new_fsm.IDLE:
       rowsout=rows;
      shiftstore.d = rows[0];//store the rows into a register
        
        new_fsm.d=new_fsm.SAVED_STATE;
      
      new_fsm.LEFT:
      if (rows[0][14] != 1){  
       alu.a = rows[0];      // shift left row 0 by 1 
      alu.b = 1;
      alu.alufn = SHL;
      

      // if right is pressed and user is not at the right edge
      // then shift right rows by 1
           
      }        
        //shiftstore.d=shiftstore.q;
        //new_fsm.d=new_fsm.SAVED_STATE;
      if (c.value  == 0){
        shiftstore.d = alu.out;
          }
       else{
          shiftstore.d = shiftstore.q;
          }
        //led = alu.out[15:8];
        
        new_fsm.d=new_fsm.LEFT;
        
      new_fsm.RIGHT:
      if (rows[0][14] != 1){  
    
    alu.a = rows[0];      // shift right row 1 by 1
    alu.b = 1;
    alu.alufn = SHR;
    shiftstore.d = alu.out;
      // if left is pressed and user is not at the left edge
      // then shift left rows by 1
         rowsout = {shiftstore.q,shiftstore.q};
      }
     shiftstore.d=shiftstore.q;
     new_fsm.d=new_fsm.SAVED_STATE;
     
     
         new_fsm.SAVED_STATE:
          alu.a = button_l;      // button_l XOR button_r
          alu.b = button_r;
          alu.alufn = XOR;
          xoroutput.d = alu.out;
        rowsout={shiftstore.q,shiftstore.q};
        //led=shiftstore.q[7:0];
      if(button_l!=1 && xoroutput.q != 16b0000000000000001){
        shiftstore.d=shiftstore.q;
        }
      else if(button_l==1 && xoroutput.q == 16b0000000000000001){
        new_fsm.d=new_fsm.LEFT; 
        c.rst = 1;  
        }
      if(button_r!=1 && xoroutput.q != 16b1){
        shiftstore.d=shiftstore.q;
        }
     if(button_r==1 && xoroutput.q == 16b1){
       new_fsm.d=new_fsm.RIGHT;
        }
        
         
    }
    
          
}
} 